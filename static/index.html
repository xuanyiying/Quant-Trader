<!DOCTYPE html>
<html>

<head>
    <title>Quant Trader Monitor</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #121212;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .card {
            background: #1e1e1e;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .status {
            display: flex;
            gap: 20px;
        }

        .status-item {
            background: #2a2a2a;
            padding: 12px 24px;
            border-radius: 8px;
            text-align: center;
            min-width: 120px;
        }

        .status-label {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .status-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #4caf50;
        }

        #chart {
            width: 100%;
            height: 650px;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        input {
            padding: 10px 16px;
            border-radius: 6px;
            border: 1px solid #333;
            background: #2a2a2a;
            color: white;
            font-size: 14px;
            outline: none;
        }

        input:focus {
            border-color: #2196f3;
        }

        button {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            background: #2196f3;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background: #1976d2;
        }

        button.secondary {
            background: #424242;
        }

        button.secondary:hover {
            background: #616161;
        }

        .up { color: #00c087; }
        .down { color: #ff3b30; }
    </style>
</head>

<body>
    <div id="app" class="container">
        <div class="header">
            <h1 style="margin:0; font-weight: 300;">Quant Trader <span style="font-weight: 700; color: #2196f3;">Monitor</span></h1>
            <div class="status">
                <div class="status-item">
                    <div class="status-label">Connection</div>
                    <div class="status-value" :style="{ color: connectionStatus === 'Connected' ? '#4caf50' : '#f44336' }">{{ connectionStatus }}</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Last Price (USDT)</div>
                    <div class="status-value" :class="priceChangeClass">{{ lastPrice }}</div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="controls">
                <input v-model="symbol" placeholder="Symbol (e.g. BTCUSDT)">
                <button @click="handleSymbolChange">Update Symbol</button>
                <button class="secondary" @click="loadHistory">Refresh History</button>
                <div style="margin-left: auto; color: #888; font-size: 0.9em;">
                    Real-time K-Line (1m)
                </div>
            </div>
            <div id="chart"></div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, watch } = Vue

        createApp({
            setup() {
                const symbol = ref('BTCUSDT')
                const connectionStatus = ref('Disconnected')
                const lastPrice = ref('0.00')
                const priceChangeClass = ref('')
                let ws = null
                let chart = null
                let prevPrice = 0

                const upColor = '#00c087';
                const upBorderColor = '#00c087';
                const downColor = '#ff3b30';
                const downBorderColor = '#ff3b30';

                const initChart = () => {
                    chart = echarts.init(document.getElementById('chart'))
                    const option = {
                        backgroundColor: '#1e1e1e',
                        animation: false,
                        legend: {
                            bottom: 10,
                            left: 'center',
                            data: ['K-Line', 'Volume'],
                            textStyle: { color: '#ccc' }
                        },
                        tooltip: {
                            trigger: 'axis',
                            axisPointer: { type: 'cross' },
                            backgroundColor: 'rgba(50, 50, 50, 0.9)',
                            borderColor: '#444',
                            textStyle: { color: '#eee' },
                            formatter: function (params) {
                                let res = params[0].name;
                                params.forEach(p => {
                                    if (p.seriesName === 'K-Line') {
                                        res += `<br/>Open: ${p.data[1]}<br/>Close: ${p.data[2]}<br/>Low: ${p.data[3]}<br/>High: ${p.data[4]}`;
                                    } else {
                                        res += `<br/>Volume: ${parseFloat(p.data).toFixed(4)}`;
                                    }
                                });
                                return res;
                            }
                        },
                        axisPointer: {
                            link: [{ xAxisIndex: 'all' }],
                            label: { backgroundColor: '#777' }
                        },
                        grid: [
                            { left: '8%', right: '8%', height: '60%' },
                            { left: '8%', right: '8%', top: '75%', height: '15%' }
                        ],
                        xAxis: [
                            {
                                type: 'category',
                                data: [],
                                boundaryGap: false,
                                axisLine: { onZero: false, lineStyle: { color: '#444' } },
                                splitLine: { show: false },
                                min: 'dataMin',
                                max: 'dataMax',
                                axisPointer: { z: 100 }
                            },
                            {
                                type: 'category',
                                gridIndex: 1,
                                data: [],
                                boundaryGap: false,
                                axisLine: { onZero: false, lineStyle: { color: '#444' } },
                                axisTick: { show: false },
                                splitLine: { show: false },
                                axisLabel: { show: false },
                                min: 'dataMin',
                                max: 'dataMax'
                            }
                        ],
                        yAxis: [
                            {
                                scale: true,
                                splitArea: { show: false },
                                axisLine: { lineStyle: { color: '#444' } },
                                splitLine: { lineStyle: { color: '#333' } },
                                axisLabel: { formatter: '{value}' }
                            },
                            {
                                scale: true,
                                gridIndex: 1,
                                splitNumber: 2,
                                axisLabel: { show: false },
                                axisLine: { show: false },
                                axisTick: { show: false },
                                splitLine: { show: false }
                            }
                        ],
                        dataZoom: [
                            {
                                type: 'inside',
                                xAxisIndex: [0, 1],
                                start: 50,
                                end: 100
                            },
                            {
                                show: true,
                                xAxisIndex: [0, 1],
                                type: 'slider',
                                top: '92%',
                                start: 50,
                                end: 100,
                                textStyle: { color: '#888' }
                            }
                        ],
                        series: [
                            {
                                name: 'K-Line',
                                type: 'candlestick',
                                data: [],
                                itemStyle: {
                                    color: upColor,
                                    color0: downColor,
                                    borderColor: upBorderColor,
                                    borderColor0: downBorderColor
                                }
                            },
                            {
                                name: 'Volume',
                                type: 'bar',
                                xAxisIndex: 1,
                                yAxisIndex: 1,
                                data: [],
                                itemStyle: {
                                    color: (params) => {
                                        // Simple color logic for volume bars
                                        return params.dataIndex > 0 && 
                                               chart.getOption().series[0].data[params.dataIndex][2] > chart.getOption().series[0].data[params.dataIndex][1]
                                               ? upColor : downColor;
                                    }
                                }
                            }
                        ]
                    }
                    chart.setOption(option)
                }

                const connectWS = () => {
                    if (ws) ws.close()
                    ws = new WebSocket('ws://' + window.location.host + '/ws')

                    ws.onopen = () => {
                        connectionStatus.value = 'Connected'
                        subscribe()
                    }

                    ws.onclose = () => {
                        connectionStatus.value = 'Disconnected'
                        setTimeout(connectWS, 5000)
                    }

                    ws.onmessage = (event) => {
                        try {
                            const msg = JSON.parse(event.data)
                            
                            // 1. Handle Trade message
                            if (msg.price && msg.symbol && msg.symbol.toUpperCase().replace(/[^A-Z]/g, '') === symbol.value.toUpperCase()) {
                                const price = parseFloat(msg.price)
                                priceChangeClass.value = price > prevPrice ? 'up' : (price < prevPrice ? 'down' : '')
                                lastPrice.value = price.toFixed(2)
                                prevPrice = price
                            }
                            
                            // 2. Handle KLine message
                            if (msg.c && msg.t && msg.symbol && msg.symbol.toUpperCase().replace(/[^A-Z]/g, '') === symbol.value.toUpperCase()) {
                                const k = msg
                                lastPrice.value = parseFloat(k.c).toFixed(2)
                                
                                const date = new Date(k.t).toLocaleDateString() + ' ' + new Date(k.t).toLocaleTimeString()
                                const candleValue = [parseFloat(k.o), parseFloat(k.c), parseFloat(k.l), parseFloat(k.h)]
                                const volumeValue = parseFloat(k.v)
                                
                                const option = chart.getOption()
                                const dates = option.xAxis[0].data
                                const candles = option.series[0].data
                                const volumes = option.series[1].data
                                
                                if (dates.length > 0 && dates[dates.length - 1] === date) {
                                    candles[candles.length - 1] = candleValue
                                    volumes[volumes.length - 1] = volumeValue
                                } else {
                                    dates.push(date)
                                    candles.push(candleValue)
                                    volumes.push(volumeValue)
                                }
                                
                                if (dates.length > 500) {
                                    dates.shift(); candles.shift(); volumes.shift();
                                }
                                
                                chart.setOption({
                                    xAxis: [{ data: dates }, { data: dates }],
                                    series: [{ data: candles }, { data: volumes }]
                                })
                            }
                        } catch (e) {
                            console.error('WS Error:', e)
                        }
                    }
                }

                const loadHistory = async () => {
                    try {
                        const res = await fetch(`/api/v1/klines/${symbol.value}?period=1m`)
                        const data = await res.json()
                        if (!Array.isArray(data)) return

                        const sortedData = data.sort((a, b) => new Date(a.t).getTime() - new Date(b.t).getTime())
                        
                        const dates = sortedData.map(k => {
                            const d = new Date(k.t)
                            return d.toLocaleDateString() + ' ' + d.toLocaleTimeString()
                        })

                        const candles = sortedData.map(k => [
                            parseFloat(k.o), parseFloat(k.c), parseFloat(k.l), parseFloat(k.h)
                        ])

                        const volumes = sortedData.map(k => parseFloat(k.v))

                        chart.setOption({
                            xAxis: [{ data: dates }, { data: dates }],
                            series: [
                                { data: candles },
                                { data: volumes }
                            ]
                        })
                        
                        if (candles.length > 0) {
                            lastPrice.value = candles[candles.length-1][1].toFixed(2)
                        }
                    } catch (e) {
                        console.error('Failed to load history:', e)
                    }
                }

                const subscribe = () => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Subscribe to K-lines
                        ws.send(JSON.stringify({
                            action: 'subscribe',
                            topic: `market.kline.1m.${symbol.value}`
                        }))
                        // Subscribe to trades
                        ws.send(JSON.stringify({
                            action: 'subscribe',
                            topic: `market.raw.*.${symbol.value}`
                        }))
                    }
                }

                const handleSymbolChange = () => {
                    symbol.value = symbol.value.toUpperCase().replace(/[^A-Z]/g, '')
                    loadHistory()
                    subscribe()
                }

                onMounted(() => {
                    initChart()
                    connectWS()
                    loadHistory()
                    window.addEventListener('resize', () => chart.resize())
                })

                return {
                    symbol,
                    connectionStatus,
                    lastPrice,
                    priceChangeClass,
                    handleSymbolChange,
                    loadHistory
                }
            }
        }).mount('#app')
    </script>
</body>

</html>
